<!DOCTYPE html><base href="/cave-story-web/"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable: no, minimum-scale: 1, maximum-scale:1" />
<title>Cave Story</title>
<style>
html, body { margin: 0; padding: 0; overflow: hidden; background: rgb(0, 0, 0); font-family: sans-serif; touch-action: none; user-select: none; -webkit-user-select: none; }
canvas { max-width: 100%; max-height: 100%; min-width: 100%; min-height: 100%; object-fit: contain; }
#rotator {
    transform: none;
    transform-origin: bottom left;
    position:absolute;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    width: 100dvw;
    height: 100dvh;
    overflow:hidden;
}

@media (pointer: coarse) and (orientation: portrait) {
    #rotator {
        transform: rotate(90deg);
        transform-origin: bottom left;
        top: -100vw;
        left: 0;
        width: 100vh;
        height: 100vw;
        width: 100dvh;
        height: 100dvw;
    }
}

object { display: none; }
#blockerLeft, #blockerRight, #weaponSwitch { display: none; }
@media (pointer: coarse) {
    object { display: block; }
    #blockerLeft, #blockerRight, #weaponSwitch { display: block; }
}

</style>
<div id=rotator>
<canvas id=canvas></canvas>
<div id="blockerLeft" style="position: absolute; top: 0; left: 0; width: 500%; height: 1000%; transform: scale(0.1); transform-origin: top left; background: transparent;"></div>
<div id="blockerRight" style="position: absolute; top: 0; left: 50%; width: 500%; height: 1000%; transform: scale(0.1); transform-origin: top left; background: transparent;"></div>
<div id="weaponSwitch" style="position: absolute; top: 0; left: 0; width: 300%; height: 200%; transform: scale(0.1); transform-origin: top left; background: transparent;"></div>
<div id=cloudSaveSyncLoginButton></div>
</div>
<script type="module">
import { GamepadEmulator } from './GamepadEmulator.js';
const emulator = new GamepadEmulator();
const gamepadEmulator = emulator.AddEmulatedGamepad(null, true);

// Don't use fullscreen API on iOS because Apple crippled it. Any touch input with a downward drag will exit fullscreen.
const ios = /iPad|iPhone|iPod/.test(navigator.platform) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
const fullscreen = () => {
    if (!ios && !document.fullscreenElement && document.documentElement.requestFullscreen) document.documentElement.requestFullscreen();
}

const buttonPad = (element, buttonUp, buttonDown, buttonLeft, buttonRight) => {
    let pointerDown = null;
    let x = 0;
    let y = 0;
    element.addEventListener('pointerdown', e => {
        e.preventDefault();
        fullscreen();
        x = e.offsetX/10;
        y = e.offsetY/10;
        pointerDown = e;
    }, {passive: false});
    element.addEventListener('pointerup', e => {
        e.preventDefault();
        fullscreen();
        emulator.PressButton(0, buttonUp, false);
        emulator.PressButton(0, buttonDown, false);
        emulator.PressButton(0, buttonLeft, false);
        emulator.PressButton(0, buttonRight, false);
        pointerDown = null;
    }, {passive: false});
    element.addEventListener('pointermove', e => {
        e.preventDefault();
        let dx = e.offsetX/10 - x;
        let dy = e.offsetY/10 - y;
        let distance = Math.sqrt(dx*dx + dy*dy);
        if (distance > 5) {
            x += dx * (distance - 5) / distance;
            y += dy * (distance - 5) / distance;
        }
        if (distance < 1.5) {
            emulator.PressButton(0, buttonUp, false);
            emulator.PressButton(0, buttonDown, false);
            emulator.PressButton(0, buttonLeft, false);
            emulator.PressButton(0, buttonRight, false);
        } else {
            let angle = Math.atan2(dy, dx);
            let up = angle > -3*Math.PI / 4 && angle < -Math.PI / 4;
            let down = angle > Math.PI / 4 && angle < 3*Math.PI / 4;
            let left = angle > 3*Math.PI / 4 || angle < -3*Math.PI / 4;
            let right = angle > -Math.PI / 4 && angle < Math.PI / 4;
            // console.log(`up: ${up}  down: ${down}  left: ${left}  right: ${right}`);
            emulator.PressButton(0, buttonUp, up);
            emulator.PressButton(0, buttonDown, down);
            emulator.PressButton(0, buttonLeft, left);
            emulator.PressButton(0, buttonRight, right);
        }
    }, {passive: false});
}
buttonPad(blockerLeft, 12, 13, 14, 15);

let buttonStart = {offsetX: 0, offsetY: 0};
blockerRight.addEventListener("pointerdown", (e) => {
    e.preventDefault();
    fullscreen();
    buttonStart = e;
    emulator.PressButton(0, 3, true);
 }, {passive: false});
blockerRight.addEventListener("pointerup", (e) => {
    e.preventDefault();
    fullscreen();
    emulator.PressButton(0, 3, false);
    emulator.PressButton(0, 1, false);
}, {passive: false});
blockerRight.addEventListener("pointermove", (e) => {
    e.preventDefault();
    let dx = e.offsetX/10 - buttonStart.offsetX/10;
    let dy = e.offsetY/10 - buttonStart.offsetY/10;
    let distance = Math.sqrt(dx*dx + dy*dy);
    if (distance > 5) {
        emulator.PressButton(0, 1, true);
    }
}, {passive: false});

let weaponSwitchStart = {offsetX: 0, offsetY: 0};
let weaponSwitched = false;
weaponSwitch.addEventListener("pointerdown", (e) => {
    e.preventDefault();
    fullscreen();
    weaponSwitchStart = e;
    weaponSwitched = false;
}, {passive: false});
weaponSwitch.addEventListener("pointerup", (e) => {
    e.preventDefault();
    fullscreen();
    if (weaponSwitched) {
        emulator.PressButton(0, 4, false);
        emulator.PressButton(0, 5, false);
    } else {
        emulator.PressButton(0, 2, true);
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            emulator.PressButton(0, 2, false);
                        });
                    });
                });
            });
        });
    }
}, {passive: false});
weaponSwitch.addEventListener("pointermove", (e) => {
    e.preventDefault();
    let dx = e.offsetX/10 - weaponSwitchStart.offsetX/10;
    let dy = e.offsetY/10 - weaponSwitchStart.offsetY/10;
    // let distance = Math.sqrt(dx*dx + dy*dy);
    if (dx > 1.5) {
        emulator.PressButton(0, 4, true);
        emulator.PressButton(0, 5, false);
        weaponSwitched = true;
    } else if (dx < -1.5) {
        emulator.PressButton(0, 4, false);
        emulator.PressButton(0, 5, true);
        weaponSwitched = true;
    }
}, {passive: false});


canvas.addEventListener("pointerdown", fullscreen);

// Prevent Safari from showing a magnifying glass on double tap and hold. C'mon Apple...
blockerLeft.addEventListener("touchstart", e=>e.preventDefault(), {passive: false});
blockerRight.addEventListener("touchstart", e=>e.preventDefault(), {passive: false});
weaponSwitch.addEventListener("touchstart", e=>e.preventDefault(), {passive: false});
canvas.addEventListener("touchstart", e=>e.preventDefault(), {passive: false});


const defaultKeyBindingKeyCodes = { "KeyZ": true, "KeyX": true, "KeyC": true, "KeyA": true, "KeyS": true, "KeyQ": true, "KeyW": true, "Enter": true, "ArrowUp": true, "ArrowDown": true, "ArrowLeft": true, "ArrowRight": true, "Escape": true, };
window.addEventListener("keydown", (e) => {
        fullscreen();
        // Emscripten SDL2 will preventDefault all keyboard events which prevents browser keyboard shortcuts from working.
        // This was supposed to be fixed in https://github.com/emscripten-core/emscripten/issues/16462 however the fix regressed.
        // This hack lets the browser handle everything, except for the default keybindings.
        if (!defaultKeyBindingKeyCodes[e.code]) e.preventDefault = () => false;
    }, { capture: true });

let idbLoaded;
let idbErrored;
let idbPromise = new Promise((a, b) => { idbLoaded = a; idbErrored = b; });
const saveFileLocation = '/libsdl/nxengine';

let gotModule;
const modulePromise = new Promise(r=>gotModule=r);
let saveFileMount = import('/cloudSaveSync.js').then((cloudSaveSync) => {
    cloudSaveSync.loginButton(cloudSaveSyncLoginButton);
    return cloudSaveSync.mount(modulePromise, saveFileLocation);
});
let syncSaveData;
import(`./nxengine-evo.js`).then(async (nxengine)=>{
    const module = await nxengine.default({
        canvas,
        arguments: [],
        print: (text)=>{
            console.log(text);
            if (/game_save: writing savefile/.test(text)) syncSaveData();
        },
        preRun: [async (module) => {
            module.addRunDependency('setup-filesystem');
            gotModule(module);
            document.addEventListener('visibilitychange', () => {
                // Silence audio when the tab is hidden.
                if (document.hidden) {
                    module.SDL2.audioContext.suspend();
                } else {
                    module.SDL2.audioContext.resume();
                }
            });
            window.addEventListener('pointerdown', () => {
                module.SDL2.audioContext.resume();
            });
            window.addEventListener('pointerup', () => {
                module.SDL2.audioContext.resume();
            });
            await fetch(`doukutsu.zip`)
                .then(response => response.arrayBuffer())
                .then(buffer => module.FS.writeFile('/doukutsu.zip', new Uint8Array(buffer)));
            syncSaveData = await saveFileMount;
            module.removeRunDependency('setup-filesystem');
        }],
    });
    return module;
});

</script>